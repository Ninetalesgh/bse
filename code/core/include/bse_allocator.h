#pragma once

#include "bse_debug.h"
#include "bse_thread.h"
#include "bse_bit.h"

namespace bse
{
  namespace memory
  {
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// General ///////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    enum class AllocatorType : u32
    {
      VirtualMemory = 0,
      Arena,
      Multipool,
      MonotonicPool
    };
    enum class AllocatorPolicy : u32
    {
      //
      //If set the container will either grow or allocate memory from parent allocator.
      //If unset overflowing allocations return nullptr.
      AllowGrowth = 0b1,
      //
      //Only relevant if container is allowed to grow.
      //If set the container will grow exponentially.
      //If unset container will grow linearly.
      GeometricGrowth = 0b10,
    };
    BSE_DEFINE_ENUM_OPERATORS_U32( AllocatorPolicy );

    struct Allocator;
    [[nodiscard]] void* allocate( Allocator* allocator, s64 size );
    [[nodiscard]] void* reallocate( Allocator* allocator, void* ptr, s64 oldSize, s64 newSize );
    void free( Allocator* allocator, void* ptr, s64 size );
    void free( Allocator* allocator, void* ptr );

    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// Virtual Memory ////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ///// Allocate pages directly from the platform,                   ///////////////////////////////////
    ///// platform->info.virtualMemoryPageSize to check the size.      ///////////////////////////////////
    ///// The size parameter is the size of the allocation,            ///////////////////////////////////
    ///// not the page count.                                          ///////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    [[nodiscard]] void* allocate_virtual_memory( s64 size );
    [[nodiscard]] void* reallocate_virtual_memory( void* ptr, s64 oldSize, s64 newSize );
    void free_virtual_memory( void* ptr );

    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// Arena /////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ///// This behaves basically like a stack.                         ///////////////////////////////////
    ///// free(arena, ptr) is ruthless and will pop back to ptr,       ///////////////////////////////////
    ///// so unless you are aware of that only ever LIFO like a stack. ///////////////////////////////////
    ///// If reallocate is called on the last allocation it won't      ///////////////////////////////////
    ///// have to move any data around, it will simple add more space. ///////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    struct Arena;
    [[nodiscard]] void* allocate( Arena* arena, s64 size );
    [[nodiscard]] void* reallocate( Arena* arena, void* ptr, s64 oldSize, s64 newSize );
    void free( Arena* arena, void* ptr );

    //free everything 
    void clear_arena( Arena* arena );

    [[nodiscard]] Arena* new_arena( Allocator* parent, s64 size, AllocatorPolicy const& policy );
    [[nodiscard]] Arena* new_arena( Allocator* parent, s64 size ) { return new_arena( parent, size, AllocatorPolicy::AllowGrowth | AllocatorPolicy::GeometricGrowth ); }
    void delete_arena( Arena* arena );

    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// MonotonicPool /////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ///// Monotonic pool allocations are of one fixed size only,       ///////////////////////////////////
    ///// specified at allocator creation.                             ///////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    struct MonotonicPool;
    [[nodiscard]] void* allocate( MonotonicPool* pool );
    [[nodiscard]] void* reallocate( MonotonicPool* pool, void* ptr, s64 oldSize, s64 newSize );
    void free( MonotonicPool* pool, void* ptr );

    [[nodiscard]] MonotonicPool* new_monotonic_pool( Allocator* parent, s64 size, s64 granularity, AllocatorPolicy const& policy );
    [[nodiscard]] MonotonicPool* new_monotonic_pool( Allocator* parent, s64 size, s64 granularity ) { return new_monotonic_pool( parent, size, granularity, AllocatorPolicy::AllowGrowth | AllocatorPolicy::GeometricGrowth ); }
    void delete_monotonic_pool( MonotonicPool* pool );

    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// Multipool /////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ///// This is a meta structure that holds monotonic allocators            ////////////////////////////
    ///// of different granularity and will allocate into the best fit.       ////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    struct Multipool;
    [[nodiscard]] void* allocate( Multipool* multipool, s64 size );
    [[nodiscard]] void* reallocate( Multipool* multipool, void* ptr, s64 oldSize, s64 newSize );
    void free( Multipool* multipool, void* ptr, s64 size );

    [[nodiscard]] Multipool* new_multipool( Allocator* parent, s64 maxPoolSize, s64 poolSizeGranularity, AllocatorPolicy const& policy );
    [[nodiscard]] Multipool* new_multipool( Allocator* parent, s64 maxPoolSize, s64 poolSizeGranularity ) { return new_multipool( parent, maxPoolSize, poolSizeGranularity, AllocatorPolicy::AllowGrowth | AllocatorPolicy::GeometricGrowth ); }
    void delete_multipool( Multipool* multipool );


    //TODO VERY IMPORTANT ALLOCATORS SAFE FOR THREADING
  };
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////// Inline //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace bse
{
  namespace memory
  {
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// General ///////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    struct Allocator
    {
      constexpr static u32 ALIGNMENT = 64;
      Allocator* parent;
      AllocatorType type;
      AllocatorPolicy policy;
      Allocator() : type( AllocatorType::VirtualMemory ) {}
    };
    //Dummy struct for the type
    static Allocator VirtualMemoryAllocator;

    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// Arena /////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    struct Arena : Allocator
    {
      char* begin;
      char* ptr;
      s64 size;
      Arena* nextArena;
    };

    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// MonotonicPool /////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    struct MonotonicPool : Allocator
    {
      struct Slot
      {
        Slot* next;
      };
      Slot* next;
      char* begin;
      MonotonicPool* nextPool;
      s64 size;
      s64 granularity;
    };

    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// Multipool /////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    struct Multipool : Allocator
    {
      MonotonicPool** pools;
      s64 poolSizeMax;
      s64 poolSizeGranularity;
      s64 defaultElementCount;
    };
  };
};