#pragma once

#include "bse_debug.h"
#include "bse_thread.h"
#include "bse_bit.h"

namespace bse
{
  namespace memory
  {
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// General ///////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    struct Allocator;
    [[nodiscard]] void* allocate( Allocator* allocator, s64 size );
    [[nodiscard]] void* reallocate( Allocator* allocator, void* ptr, s64 oldSize, s64 newSize );
    void free( Allocator* allocator, void* ptr, s64 size );
    void free( Allocator* allocator, void* ptr );

    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// Arena /////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ///// This behaves basically like a stack,                                  //////////////////////////
    ///// free is ruthless and will free everything past the argument address   //////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    struct Arena;
    [[nodiscard]] void* allocate( Arena* arena, s64 size );
    [[nodiscard]] void* reallocate( Arena* arena, void* ptr, s64 oldSize, s64 newSize );
    void free( Arena* arena, void* ptr, s64 size );
    void free( Arena* arena, void* ptr );


    [[nodiscard]] Arena* create_arena( Arena* parent, s64 size );
    void create_arena( Arena& arena, s64 size );
    void reset_arena( Arena* arena );

    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// Multipool /////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    struct Multipool;
    [[nodiscard]] void* allocate( Multipool* multipool, s64 size );
    [[nodiscard]] void* reallocate( Multipool* multipool, void* ptr, s64 oldSize, s64 newSize );
    void free( Multipool* multipool, void* ptr, s64 size );
    void free( Multipool* multipool, void* ptr );

  };
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////// Inline //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace bse
{
  namespace memory
  {
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// General ///////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    struct Allocator
    {
      enum class Type : u64
      {
        Arena,
        Multipool,
        Monotonic
      } type;
      Allocator* parent;
    };

    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// Arena /////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    struct Arena : Allocator
    {
      char* beginPtr;
      char* ptr;
      char* highestCommitPtr;
      char* endPtr;
    };


    Arena* create_arena( Arena* parent, s64 size )
    {
      Arena* result = (Arena*) allocate( parent, sizeof( Arena ) );
      char* ptr = (char*) allocate( parent, size );

      result->type = Allocator::Type::Arena;
      result->parent = parent;
      result->beginPtr = ptr;
      result->ptr = ptr;
      result->highestCommitPtr = ptr;
      result->endPtr = ptr + size;

      return result;
    }


    void reset_arena( Arena* arena )
    {
      arena->ptr = arena->beginPtr;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////// Multipool /////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    struct MonotonicPool : Allocator
    {
      struct Slot
      {
        Slot* next;
      };
      Slot* next;
      char* begin;
      MonotonicPool* nextPool;
      s32 elementSize;
      s32 writeIndex;
      s32 elementCount;
    };

    struct Multipool : Allocator
    {
      MonotonicPool* pools;
      s64 poolSizeMax;
      s64 poolSizeGranularity;
    };


    //TODO allocate these so the ptr fits on a cacheline and the pool struct sits at the end of it?
    //TODO if next gets overwritten, we can check for this and it might be a good debugging tool?



    void create_multipool()
    {
      s32 poolSizeMax = 32;
      s32 poolSizeGranularity = 4;

      // Multipool result;
       //1 + ((poolSizeMax - 1) / poolSizeGranularity)
       //allocate result.pools TODO
       //set them to 0
    }


  };
};